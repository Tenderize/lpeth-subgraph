schema {
  query: Query
  subscription: Subscription
}

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

type BatchUnlockBought {
  id: Bytes!
  caller: Bytes!
  amount: BigInt!
  reward: BigInt!
  lpFees: BigInt!
  tokenIds: [BigInt!]!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input BatchUnlockBought_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  caller: Bytes
  caller_not: Bytes
  caller_gt: Bytes
  caller_lt: Bytes
  caller_gte: Bytes
  caller_lte: Bytes
  caller_in: [Bytes!]
  caller_not_in: [Bytes!]
  caller_contains: Bytes
  caller_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  reward: BigInt
  reward_not: BigInt
  reward_gt: BigInt
  reward_lt: BigInt
  reward_gte: BigInt
  reward_lte: BigInt
  reward_in: [BigInt!]
  reward_not_in: [BigInt!]
  lpFees: BigInt
  lpFees_not: BigInt
  lpFees_gt: BigInt
  lpFees_lt: BigInt
  lpFees_gte: BigInt
  lpFees_lte: BigInt
  lpFees_in: [BigInt!]
  lpFees_not_in: [BigInt!]
  tokenIds: [BigInt!]
  tokenIds_not: [BigInt!]
  tokenIds_contains: [BigInt!]
  tokenIds_contains_nocase: [BigInt!]
  tokenIds_not_contains: [BigInt!]
  tokenIds_not_contains_nocase: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BatchUnlockBought_filter]
  or: [BatchUnlockBought_filter]
}

enum BatchUnlockBought_orderBy {
  id
  caller
  amount
  reward
  lpFees
  tokenIds
  blockNumber
  blockTimestamp
  transactionHash
}

type BatchUnlockRedeemed {
  id: Bytes!
  relayer: Bytes!
  amount: BigInt!
  reward: BigInt!
  lpFees: BigInt!
  tokenIds: [BigInt!]!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input BatchUnlockRedeemed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  relayer: Bytes
  relayer_not: Bytes
  relayer_gt: Bytes
  relayer_lt: Bytes
  relayer_gte: Bytes
  relayer_lte: Bytes
  relayer_in: [Bytes!]
  relayer_not_in: [Bytes!]
  relayer_contains: Bytes
  relayer_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  reward: BigInt
  reward_not: BigInt
  reward_gt: BigInt
  reward_lt: BigInt
  reward_gte: BigInt
  reward_lte: BigInt
  reward_in: [BigInt!]
  reward_not_in: [BigInt!]
  lpFees: BigInt
  lpFees_not: BigInt
  lpFees_gt: BigInt
  lpFees_lt: BigInt
  lpFees_gte: BigInt
  lpFees_lte: BigInt
  lpFees_in: [BigInt!]
  lpFees_not_in: [BigInt!]
  tokenIds: [BigInt!]
  tokenIds_not: [BigInt!]
  tokenIds_contains: [BigInt!]
  tokenIds_contains_nocase: [BigInt!]
  tokenIds_not_contains: [BigInt!]
  tokenIds_not_contains_nocase: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BatchUnlockRedeemed_filter]
  or: [BatchUnlockRedeemed_filter]
}

enum BatchUnlockRedeemed_orderBy {
  id
  relayer
  amount
  reward
  lpFees
  tokenIds
  blockNumber
  blockTimestamp
  transactionHash
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type ClaimWithdrawRequest {
  id: Bytes!
  requestId: BigInt!
  to: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input ClaimWithdrawRequest_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  requestId: BigInt
  requestId_not: BigInt
  requestId_gt: BigInt
  requestId_lt: BigInt
  requestId_gte: BigInt
  requestId_lte: BigInt
  requestId_in: [BigInt!]
  requestId_not_in: [BigInt!]
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClaimWithdrawRequest_filter]
  or: [ClaimWithdrawRequest_filter]
}

enum ClaimWithdrawRequest_orderBy {
  id
  requestId
  to
  amount
  blockNumber
  blockTimestamp
  transactionHash
}

type Deposit {
  id: Bytes!
  from: Bytes!
  amount: BigInt!
  lpSharesMinted: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Deposit_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lpSharesMinted: BigInt
  lpSharesMinted_not: BigInt
  lpSharesMinted_gt: BigInt
  lpSharesMinted_lt: BigInt
  lpSharesMinted_gte: BigInt
  lpSharesMinted_lte: BigInt
  lpSharesMinted_in: [BigInt!]
  lpSharesMinted_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Deposit_filter]
  or: [Deposit_filter]
}

enum Deposit_orderBy {
  id
  from
  amount
  lpSharesMinted
  blockNumber
  blockTimestamp
  transactionHash
}

"""
8 bytes signed integer

"""
scalar Int8

type LiquidityPosition {
  id: ID!
  user: User!
  pool: SwapPool!
  shares: BigInt!
  netDeposits: BigInt!
}

input LiquidityPosition_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: SwapPool_filter
  shares: BigInt
  shares_not: BigInt
  shares_gt: BigInt
  shares_lt: BigInt
  shares_gte: BigInt
  shares_lte: BigInt
  shares_in: [BigInt!]
  shares_not_in: [BigInt!]
  netDeposits: BigInt
  netDeposits_not: BigInt
  netDeposits_gt: BigInt
  netDeposits_lt: BigInt
  netDeposits_gte: BigInt
  netDeposits_lte: BigInt
  netDeposits_in: [BigInt!]
  netDeposits_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPosition_filter]
  or: [LiquidityPosition_filter]
}

enum LiquidityPosition_orderBy {
  id
  user
  user__id
  pool
  pool__id
  pool__totalSupply
  pool__liabilities
  pool__unlocking
  pool__volume
  pool__volumeUSD
  pool__fees
  pool__feesUSD
  pool__lpRewards
  pool__lpRewardsUSD
  pool__treasuryCut
  pool__treasuryCutUSD
  pool__numSwaps
  pool__lpToken
  shares
  netDeposits
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  batchUnlockBought(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BatchUnlockBought
  batchUnlockBoughts(
    skip: Int = 0
    first: Int = 100
    orderBy: BatchUnlockBought_orderBy
    orderDirection: OrderDirection
    where: BatchUnlockBought_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BatchUnlockBought!]!
  batchUnlockRedeemed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BatchUnlockRedeemed
  batchUnlockRedeemeds(
    skip: Int = 0
    first: Int = 100
    orderBy: BatchUnlockRedeemed_orderBy
    orderDirection: OrderDirection
    where: BatchUnlockRedeemed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BatchUnlockRedeemed!]!
  claimWithdrawRequest(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClaimWithdrawRequest
  claimWithdrawRequests(
    skip: Int = 0
    first: Int = 100
    orderBy: ClaimWithdrawRequest_orderBy
    orderDirection: OrderDirection
    where: ClaimWithdrawRequest_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClaimWithdrawRequest!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  deposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  relayerRewardsClaimed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RelayerRewardsClaimed
  relayerRewardsClaimeds(
    skip: Int = 0
    first: Int = 100
    orderBy: RelayerRewardsClaimed_orderBy
    orderDirection: OrderDirection
    where: RelayerRewardsClaimed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RelayerRewardsClaimed!]!
  swapPool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapPool
  swapPools(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapPool_orderBy
    orderDirection: OrderDirection
    where: SwapPool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapPool!]!
  swapPoolDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapPoolDay
  swapPoolDays(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapPoolDay_orderBy
    orderDirection: OrderDirection
    where: SwapPoolDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapPoolDay!]!
  unlockBought(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnlockBought
  unlockBoughts(
    skip: Int = 0
    first: Int = 100
    orderBy: UnlockBought_orderBy
    orderDirection: OrderDirection
    where: UnlockBought_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnlockBought!]!
  unlockRedeemed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnlockRedeemed
  unlockRedeemeds(
    skip: Int = 0
    first: Int = 100
    orderBy: UnlockRedeemed_orderBy
    orderDirection: OrderDirection
    where: UnlockRedeemed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnlockRedeemed!]!
  withdraw(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdraw
  withdraws(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdraw_orderBy
    orderDirection: OrderDirection
    where: Withdraw_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdraw!]!
  swapLPTokenTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapLPTokenTransfer
  swapLPTokenTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapLPTokenTransfer_orderBy
    orderDirection: OrderDirection
    where: SwapLPTokenTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapLPTokenTransfer!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  liquidityPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPosition
  liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPosition_orderBy
    orderDirection: OrderDirection
    where: LiquidityPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPosition!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RelayerRewardsClaimed {
  id: Bytes!
  relayer: Bytes!
  rewards: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input RelayerRewardsClaimed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  relayer: Bytes
  relayer_not: Bytes
  relayer_gt: Bytes
  relayer_lt: Bytes
  relayer_gte: Bytes
  relayer_lte: Bytes
  relayer_in: [Bytes!]
  relayer_not_in: [Bytes!]
  relayer_contains: Bytes
  relayer_not_contains: Bytes
  rewards: BigInt
  rewards_not: BigInt
  rewards_gt: BigInt
  rewards_lt: BigInt
  rewards_gte: BigInt
  rewards_lte: BigInt
  rewards_in: [BigInt!]
  rewards_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RelayerRewardsClaimed_filter]
  or: [RelayerRewardsClaimed_filter]
}

enum RelayerRewardsClaimed_orderBy {
  id
  relayer
  rewards
  blockNumber
  blockTimestamp
  transactionHash
}

type Subscription {
  batchUnlockBought(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BatchUnlockBought
  batchUnlockBoughts(
    skip: Int = 0
    first: Int = 100
    orderBy: BatchUnlockBought_orderBy
    orderDirection: OrderDirection
    where: BatchUnlockBought_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BatchUnlockBought!]!
  batchUnlockRedeemed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BatchUnlockRedeemed
  batchUnlockRedeemeds(
    skip: Int = 0
    first: Int = 100
    orderBy: BatchUnlockRedeemed_orderBy
    orderDirection: OrderDirection
    where: BatchUnlockRedeemed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BatchUnlockRedeemed!]!
  claimWithdrawRequest(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClaimWithdrawRequest
  claimWithdrawRequests(
    skip: Int = 0
    first: Int = 100
    orderBy: ClaimWithdrawRequest_orderBy
    orderDirection: OrderDirection
    where: ClaimWithdrawRequest_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClaimWithdrawRequest!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  deposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  deposits(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    where: Deposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposit!]!
  relayerRewardsClaimed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RelayerRewardsClaimed
  relayerRewardsClaimeds(
    skip: Int = 0
    first: Int = 100
    orderBy: RelayerRewardsClaimed_orderBy
    orderDirection: OrderDirection
    where: RelayerRewardsClaimed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RelayerRewardsClaimed!]!
  swapPool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapPool
  swapPools(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapPool_orderBy
    orderDirection: OrderDirection
    where: SwapPool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapPool!]!
  swapPoolDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapPoolDay
  swapPoolDays(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapPoolDay_orderBy
    orderDirection: OrderDirection
    where: SwapPoolDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapPoolDay!]!
  unlockBought(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnlockBought
  unlockBoughts(
    skip: Int = 0
    first: Int = 100
    orderBy: UnlockBought_orderBy
    orderDirection: OrderDirection
    where: UnlockBought_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnlockBought!]!
  unlockRedeemed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnlockRedeemed
  unlockRedeemeds(
    skip: Int = 0
    first: Int = 100
    orderBy: UnlockRedeemed_orderBy
    orderDirection: OrderDirection
    where: UnlockRedeemed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnlockRedeemed!]!
  withdraw(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdraw
  withdraws(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdraw_orderBy
    orderDirection: OrderDirection
    where: Withdraw_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdraw!]!
  swapLPTokenTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapLPTokenTransfer
  swapLPTokenTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapLPTokenTransfer_orderBy
    orderDirection: OrderDirection
    where: SwapLPTokenTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapLPTokenTransfer!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  liquidityPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPosition
  liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPosition_orderBy
    orderDirection: OrderDirection
    where: LiquidityPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPosition!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Swap {
  id: ID!
  pool: SwapPool!
  asset: Bytes!
  from: Bytes!
  amount: BigInt!
  amountUSD: BigDecimal!
  fee: BigInt!
  feeUSD: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SwapLPTokenTransfer {
  id: ID!
  timestamp: Int!
  blockNumber: BigInt!
  from: String!
  to: String!
  amount: BigInt!
  SwapPool: SwapPool!
}

input SwapLPTokenTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  SwapPool: String
  SwapPool_not: String
  SwapPool_gt: String
  SwapPool_lt: String
  SwapPool_gte: String
  SwapPool_lte: String
  SwapPool_in: [String!]
  SwapPool_not_in: [String!]
  SwapPool_contains: String
  SwapPool_contains_nocase: String
  SwapPool_not_contains: String
  SwapPool_not_contains_nocase: String
  SwapPool_starts_with: String
  SwapPool_starts_with_nocase: String
  SwapPool_not_starts_with: String
  SwapPool_not_starts_with_nocase: String
  SwapPool_ends_with: String
  SwapPool_ends_with_nocase: String
  SwapPool_not_ends_with: String
  SwapPool_not_ends_with_nocase: String
  SwapPool_: SwapPool_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SwapLPTokenTransfer_filter]
  or: [SwapLPTokenTransfer_filter]
}

enum SwapLPTokenTransfer_orderBy {
  id
  timestamp
  blockNumber
  from
  to
  amount
  SwapPool
  SwapPool__id
  SwapPool__totalSupply
  SwapPool__liabilities
  SwapPool__unlocking
  SwapPool__volume
  SwapPool__volumeUSD
  SwapPool__fees
  SwapPool__feesUSD
  SwapPool__lpRewards
  SwapPool__lpRewardsUSD
  SwapPool__treasuryCut
  SwapPool__treasuryCutUSD
  SwapPool__numSwaps
  SwapPool__lpToken
}

type SwapPool {
  id: ID!
  totalSupply: BigInt!
  liabilities: BigInt!
  unlocking: BigInt!
  volume: BigInt!
  volumeUSD: BigDecimal!
  fees: BigInt!
  feesUSD: BigDecimal!
  lpRewards: BigInt!
  lpRewardsUSD: BigDecimal!
  treasuryCut: BigInt!
  treasuryCutUSD: BigDecimal!
  numSwaps: BigInt!
  lpToken: Bytes!
  poolDays(skip: Int = 0, first: Int = 100, orderBy: SwapPoolDay_orderBy, orderDirection: OrderDirection, where: SwapPoolDay_filter): [SwapPoolDay!]!
}

type SwapPoolDay {
  id: ID!
  date: Int!
  pool: SwapPool!
  totalSupply: BigInt!
  liabilities: BigInt!
  unlocking: BigInt!
  volume: BigInt!
  volumeUSD: BigDecimal!
  fees: BigInt!
  feesUSD: BigDecimal!
  lpRewards: BigInt!
  lpRewardsUSD: BigDecimal!
  treasuryCut: BigInt!
  treasuryCutUSD: BigDecimal!
}

input SwapPoolDay_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: SwapPool_filter
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  liabilities: BigInt
  liabilities_not: BigInt
  liabilities_gt: BigInt
  liabilities_lt: BigInt
  liabilities_gte: BigInt
  liabilities_lte: BigInt
  liabilities_in: [BigInt!]
  liabilities_not_in: [BigInt!]
  unlocking: BigInt
  unlocking_not: BigInt
  unlocking_gt: BigInt
  unlocking_lt: BigInt
  unlocking_gte: BigInt
  unlocking_lte: BigInt
  unlocking_in: [BigInt!]
  unlocking_not_in: [BigInt!]
  volume: BigInt
  volume_not: BigInt
  volume_gt: BigInt
  volume_lt: BigInt
  volume_gte: BigInt
  volume_lte: BigInt
  volume_in: [BigInt!]
  volume_not_in: [BigInt!]
  volumeUSD: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_lt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_not_in: [BigDecimal!]
  fees: BigInt
  fees_not: BigInt
  fees_gt: BigInt
  fees_lt: BigInt
  fees_gte: BigInt
  fees_lte: BigInt
  fees_in: [BigInt!]
  fees_not_in: [BigInt!]
  feesUSD: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_lt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_not_in: [BigDecimal!]
  lpRewards: BigInt
  lpRewards_not: BigInt
  lpRewards_gt: BigInt
  lpRewards_lt: BigInt
  lpRewards_gte: BigInt
  lpRewards_lte: BigInt
  lpRewards_in: [BigInt!]
  lpRewards_not_in: [BigInt!]
  lpRewardsUSD: BigDecimal
  lpRewardsUSD_not: BigDecimal
  lpRewardsUSD_gt: BigDecimal
  lpRewardsUSD_lt: BigDecimal
  lpRewardsUSD_gte: BigDecimal
  lpRewardsUSD_lte: BigDecimal
  lpRewardsUSD_in: [BigDecimal!]
  lpRewardsUSD_not_in: [BigDecimal!]
  treasuryCut: BigInt
  treasuryCut_not: BigInt
  treasuryCut_gt: BigInt
  treasuryCut_lt: BigInt
  treasuryCut_gte: BigInt
  treasuryCut_lte: BigInt
  treasuryCut_in: [BigInt!]
  treasuryCut_not_in: [BigInt!]
  treasuryCutUSD: BigDecimal
  treasuryCutUSD_not: BigDecimal
  treasuryCutUSD_gt: BigDecimal
  treasuryCutUSD_lt: BigDecimal
  treasuryCutUSD_gte: BigDecimal
  treasuryCutUSD_lte: BigDecimal
  treasuryCutUSD_in: [BigDecimal!]
  treasuryCutUSD_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SwapPoolDay_filter]
  or: [SwapPoolDay_filter]
}

enum SwapPoolDay_orderBy {
  id
  date
  pool
  pool__id
  pool__totalSupply
  pool__liabilities
  pool__unlocking
  pool__volume
  pool__volumeUSD
  pool__fees
  pool__feesUSD
  pool__lpRewards
  pool__lpRewardsUSD
  pool__treasuryCut
  pool__treasuryCutUSD
  pool__numSwaps
  pool__lpToken
  totalSupply
  liabilities
  unlocking
  volume
  volumeUSD
  fees
  feesUSD
  lpRewards
  lpRewardsUSD
  treasuryCut
  treasuryCutUSD
}

input SwapPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  liabilities: BigInt
  liabilities_not: BigInt
  liabilities_gt: BigInt
  liabilities_lt: BigInt
  liabilities_gte: BigInt
  liabilities_lte: BigInt
  liabilities_in: [BigInt!]
  liabilities_not_in: [BigInt!]
  unlocking: BigInt
  unlocking_not: BigInt
  unlocking_gt: BigInt
  unlocking_lt: BigInt
  unlocking_gte: BigInt
  unlocking_lte: BigInt
  unlocking_in: [BigInt!]
  unlocking_not_in: [BigInt!]
  volume: BigInt
  volume_not: BigInt
  volume_gt: BigInt
  volume_lt: BigInt
  volume_gte: BigInt
  volume_lte: BigInt
  volume_in: [BigInt!]
  volume_not_in: [BigInt!]
  volumeUSD: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_lt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_not_in: [BigDecimal!]
  fees: BigInt
  fees_not: BigInt
  fees_gt: BigInt
  fees_lt: BigInt
  fees_gte: BigInt
  fees_lte: BigInt
  fees_in: [BigInt!]
  fees_not_in: [BigInt!]
  feesUSD: BigDecimal
  feesUSD_not: BigDecimal
  feesUSD_gt: BigDecimal
  feesUSD_lt: BigDecimal
  feesUSD_gte: BigDecimal
  feesUSD_lte: BigDecimal
  feesUSD_in: [BigDecimal!]
  feesUSD_not_in: [BigDecimal!]
  lpRewards: BigInt
  lpRewards_not: BigInt
  lpRewards_gt: BigInt
  lpRewards_lt: BigInt
  lpRewards_gte: BigInt
  lpRewards_lte: BigInt
  lpRewards_in: [BigInt!]
  lpRewards_not_in: [BigInt!]
  lpRewardsUSD: BigDecimal
  lpRewardsUSD_not: BigDecimal
  lpRewardsUSD_gt: BigDecimal
  lpRewardsUSD_lt: BigDecimal
  lpRewardsUSD_gte: BigDecimal
  lpRewardsUSD_lte: BigDecimal
  lpRewardsUSD_in: [BigDecimal!]
  lpRewardsUSD_not_in: [BigDecimal!]
  treasuryCut: BigInt
  treasuryCut_not: BigInt
  treasuryCut_gt: BigInt
  treasuryCut_lt: BigInt
  treasuryCut_gte: BigInt
  treasuryCut_lte: BigInt
  treasuryCut_in: [BigInt!]
  treasuryCut_not_in: [BigInt!]
  treasuryCutUSD: BigDecimal
  treasuryCutUSD_not: BigDecimal
  treasuryCutUSD_gt: BigDecimal
  treasuryCutUSD_lt: BigDecimal
  treasuryCutUSD_gte: BigDecimal
  treasuryCutUSD_lte: BigDecimal
  treasuryCutUSD_in: [BigDecimal!]
  treasuryCutUSD_not_in: [BigDecimal!]
  numSwaps: BigInt
  numSwaps_not: BigInt
  numSwaps_gt: BigInt
  numSwaps_lt: BigInt
  numSwaps_gte: BigInt
  numSwaps_lte: BigInt
  numSwaps_in: [BigInt!]
  numSwaps_not_in: [BigInt!]
  lpToken: Bytes
  lpToken_not: Bytes
  lpToken_gt: Bytes
  lpToken_lt: Bytes
  lpToken_gte: Bytes
  lpToken_lte: Bytes
  lpToken_in: [Bytes!]
  lpToken_not_in: [Bytes!]
  lpToken_contains: Bytes
  lpToken_not_contains: Bytes
  poolDays_: SwapPoolDay_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SwapPool_filter]
  or: [SwapPool_filter]
}

enum SwapPool_orderBy {
  id
  totalSupply
  liabilities
  unlocking
  volume
  volumeUSD
  fees
  feesUSD
  lpRewards
  lpRewardsUSD
  treasuryCut
  treasuryCutUSD
  numSwaps
  lpToken
  poolDays
}

input Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: SwapPool_filter
  asset: Bytes
  asset_not: Bytes
  asset_gt: Bytes
  asset_lt: Bytes
  asset_gte: Bytes
  asset_lte: Bytes
  asset_in: [Bytes!]
  asset_not_in: [Bytes!]
  asset_contains: Bytes
  asset_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  amountUSD: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_lt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_not_in: [BigDecimal!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  feeUSD: BigDecimal
  feeUSD_not: BigDecimal
  feeUSD_gt: BigDecimal
  feeUSD_lt: BigDecimal
  feeUSD_gte: BigDecimal
  feeUSD_lte: BigDecimal
  feeUSD_in: [BigDecimal!]
  feeUSD_not_in: [BigDecimal!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Swap_filter]
  or: [Swap_filter]
}

enum Swap_orderBy {
  id
  pool
  pool__id
  pool__totalSupply
  pool__liabilities
  pool__unlocking
  pool__volume
  pool__volumeUSD
  pool__fees
  pool__feesUSD
  pool__lpRewards
  pool__lpRewardsUSD
  pool__treasuryCut
  pool__treasuryCutUSD
  pool__numSwaps
  pool__lpToken
  asset
  from
  amount
  amountUSD
  fee
  feeUSD
  blockNumber
  blockTimestamp
  transactionHash
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type UnlockBought {
  id: Bytes!
  caller: Bytes!
  tokenId: BigInt!
  amount: BigInt!
  reward: BigInt!
  lpFees: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input UnlockBought_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  caller: Bytes
  caller_not: Bytes
  caller_gt: Bytes
  caller_lt: Bytes
  caller_gte: Bytes
  caller_lte: Bytes
  caller_in: [Bytes!]
  caller_not_in: [Bytes!]
  caller_contains: Bytes
  caller_not_contains: Bytes
  tokenId: BigInt
  tokenId_not: BigInt
  tokenId_gt: BigInt
  tokenId_lt: BigInt
  tokenId_gte: BigInt
  tokenId_lte: BigInt
  tokenId_in: [BigInt!]
  tokenId_not_in: [BigInt!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  reward: BigInt
  reward_not: BigInt
  reward_gt: BigInt
  reward_lt: BigInt
  reward_gte: BigInt
  reward_lte: BigInt
  reward_in: [BigInt!]
  reward_not_in: [BigInt!]
  lpFees: BigInt
  lpFees_not: BigInt
  lpFees_gt: BigInt
  lpFees_lt: BigInt
  lpFees_gte: BigInt
  lpFees_lte: BigInt
  lpFees_in: [BigInt!]
  lpFees_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UnlockBought_filter]
  or: [UnlockBought_filter]
}

enum UnlockBought_orderBy {
  id
  caller
  tokenId
  amount
  reward
  lpFees
  blockNumber
  blockTimestamp
  transactionHash
}

type UnlockRedeemed {
  id: Bytes!
  relayer: Bytes!
  tokenId: BigInt!
  amount: BigInt!
  reward: BigInt!
  lpFees: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input UnlockRedeemed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  relayer: Bytes
  relayer_not: Bytes
  relayer_gt: Bytes
  relayer_lt: Bytes
  relayer_gte: Bytes
  relayer_lte: Bytes
  relayer_in: [Bytes!]
  relayer_not_in: [Bytes!]
  relayer_contains: Bytes
  relayer_not_contains: Bytes
  tokenId: BigInt
  tokenId_not: BigInt
  tokenId_gt: BigInt
  tokenId_lt: BigInt
  tokenId_gte: BigInt
  tokenId_lte: BigInt
  tokenId_in: [BigInt!]
  tokenId_not_in: [BigInt!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  reward: BigInt
  reward_not: BigInt
  reward_gt: BigInt
  reward_lt: BigInt
  reward_gte: BigInt
  reward_lte: BigInt
  reward_in: [BigInt!]
  reward_not_in: [BigInt!]
  lpFees: BigInt
  lpFees_not: BigInt
  lpFees_gt: BigInt
  lpFees_lt: BigInt
  lpFees_gte: BigInt
  lpFees_lte: BigInt
  lpFees_in: [BigInt!]
  lpFees_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UnlockRedeemed_filter]
  or: [UnlockRedeemed_filter]
}

enum UnlockRedeemed_orderBy {
  id
  relayer
  tokenId
  amount
  reward
  lpFees
  blockNumber
  blockTimestamp
  transactionHash
}

type User {
  id: ID!
  liquidityPositions(skip: Int = 0, first: Int = 100, orderBy: LiquidityPosition_orderBy, orderDirection: OrderDirection, where: LiquidityPosition_filter): [LiquidityPosition!]
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  liquidityPositions_: LiquidityPosition_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  or: [User_filter]
}

enum User_orderBy {
  id
  liquidityPositions
}

type Withdraw {
  id: Bytes!
  to: Bytes!
  amount: BigInt!
  lpSharesBurnt: BigInt!
  requestId: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Withdraw_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lpSharesBurnt: BigInt
  lpSharesBurnt_not: BigInt
  lpSharesBurnt_gt: BigInt
  lpSharesBurnt_lt: BigInt
  lpSharesBurnt_gte: BigInt
  lpSharesBurnt_lte: BigInt
  lpSharesBurnt_in: [BigInt!]
  lpSharesBurnt_not_in: [BigInt!]
  requestId: BigInt
  requestId_not: BigInt
  requestId_gt: BigInt
  requestId_lt: BigInt
  requestId_gte: BigInt
  requestId_lte: BigInt
  requestId_in: [BigInt!]
  requestId_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Withdraw_filter]
  or: [Withdraw_filter]
}

enum Withdraw_orderBy {
  id
  to
  amount
  lpSharesBurnt
  requestId
  blockNumber
  blockTimestamp
  transactionHash
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}